# /home/deploy/www/YaWare_Bot/dashboard_app/tasks.py
from __future__ import annotations

import os
import logging
from datetime import date, timedelta
from calendar import monthrange

from .models import AttendanceRecord, db

logger = logging.getLogger("ctrlbot.scheduler")
if not logger.handlers:
    logger.setLevel(logging.INFO)
    _h = logging.StreamHandler()
    _h.setFormatter(logging.Formatter("%(message)s"))
    logger.addHandler(_h)
    logger.propagate = False


# ---- універсальний виклик “онови БД за конкретну дату” з модуля tasks/update_attendance ----
def _call_update_for_date(d: date):\n\
    \"\"\"Інтроспективно викликає апдейтер з tasks/update_attendance.py для дати d.\"\"\"\n\
    import inspect\n\
    try:\n\
        from tasks import update_attendance as ua\n\
    except Exception as e:\n\
        raise RuntimeError(f\"Не знайшов tasks/update_attendance.py: {e}\")\n\
\n\
    # спочатку — відомі імена\n\
    preferred = (\n\
        \"update_for_date\", \"sync_date\", \"update_day\", \"run_for_date\",\n\
        \"process_date\", \"sync_attendance_for_date\",\n\
    )\n\
    funcs = []\n\
    for name in preferred:\n\
        fn = getattr(ua, name, None)\n\
        if callable(fn):\n\
            funcs.append((name, fn))\n\
    # якщо не знайшли — беремо ВСІ функції модуля як fallback\n\
    if not funcs:\n\
        for name, fn in inspect.getmembers(ua, inspect.isfunction):\n\
            funcs.append((name, fn))\n\
\n\
    last_err = None\n\
    # ключі, якими може називатись дата\n\
    date_keys = (\"date\", \"check_date\", \"target_date\", \"day\", \"d\", \"dt\")\n\
\n\
    for name, fn in funcs:\n\
        try:\n\
            sig = inspect.signature(fn)\n\
        except Exception:\n\
            sig = None\n\
\n\
        # збираємо kwargs за реальною сигнатурою\n\
        kwargs = {}\n\
        if sig is not None:\n\
            params = sig.parameters\n\
            # якщо є будь-який з date_keys — ставимо як kw\n\
            for k in date_keys:\n\
                if k in params:\n\
                    kwargs[k] = d\n\
                    break\n\
            # якщо є include_absent — виставимо True\n\
            if \"include_absent\" in params:\n\
                kwargs[\"include_absent\"] = True\n\
\n\
        # 1) якщо зібрали kwargs із датою — пробуємо kw-виклик\n\
        if kwargs and any(k in kwargs for k in date_keys):\n\
            try:\n\
                return fn(**kwargs)\n\
            except TypeError as e:\n\
                last_err = e\n\
        # 2) пробуємо позиційний виклик (лише дата)\n\
        try:\n\
            return fn(d)\n\
        except TypeError as e:\n\
            last_err = e\n\
        # 3) пробуємо позиційний + include_absent\n\
        try:\n\
            return fn(d, True)\n\
        except TypeError as e:\n\
            last_err = e\n\
        # 4) остання спроба: якщо є тільки kw-only include_absent\n\
        try:\n\
            return fn(d, include_absent=True)\n\
        except TypeError as e:\n\
            last_err = e\n\
            continue\n\
\n\
    raise AttributeError(\n\
        \"Не знайшов сумісну функцію в tasks/update_attendance.py. \"\n\
        f\"Остання помилка: {last_err!r}\"\n\
    )\n' /home/deploy/www/YaWare_Bot/dashboard_app/tasks.py

# === ЗАВДАННЯ ===
def sync_yesterday():
    target = date.today() - timedelta(days=1)
    _call_update_for_date(target)


def sync_prev_month():
    today = date.today()
    prev_month_last_day = today.replace(day=1) - timedelta(days=1)
    year, month = prev_month_last_day.year, prev_month_last_day.month

    start_day = date(year, month, 1)
    days = monthrange(year, month)[1]
    for i in range(days):
        d = start_day + timedelta(days=i)
        _call_update_for_date(d)


def cleanup_old_records():
    """
    Видаляємо все, що старше двох місяців і НЕ має manual_* правок:
    залишаємо тільки «поточний + минулий» місяці.
    """
    cutoff = date.today().replace(day=1)
    prev_month_cutoff = (cutoff - timedelta(days=1)).replace(day=1)

    deleted = (
        AttendanceRecord.query.filter(
            AttendanceRecord.record_date < prev_month_cutoff,
            AttendanceRecord.manual_notes.is_(False),
            AttendanceRecord.manual_hours.is_(False),
            AttendanceRecord.manual_status.is_(False),
        ).delete(synchronize_session=False)
    )
    db.session.commit()
    logger.info(f"[cleanup_old_records] Deleted {deleted} outdated rows.")


# === РЕЄСТРАЦІЯ ===
def register_tasks(app):
    """
    Піднімаємо APScheduler рівно один раз у воркері Gunicorn.
    (workers=1 у systemd вже стоїть — тож буде рівно один scheduler)
    """
    if app.config.get("_APS_INIT_DONE"):
        return
    app.config["_APS_INIT_DONE"] = True

    if not app.config.get("ENABLE_SCHEDULER", False):
        logger.info("[scheduler] disabled (ENABLE_SCHEDULER!=1)")
        return

    from apscheduler.schedulers.background import BackgroundScheduler
    tz = os.getenv("TZ", "Europe/Warsaw")
    scheduler = BackgroundScheduler(timezone=tz)

    # розклад продакшн:
    scheduler.add_job(sync_yesterday,      "cron", hour=2,  minute=0)
    scheduler.add_job(sync_prev_month,     "cron", day=1,   hour=2, minute=30)
    scheduler.add_job(cleanup_old_records, "cron", day="*/3", hour=3, minute=0)

    scheduler.start()
    logger.info("[scheduler] jobs registered: sync_yesterday, sync_prev_month, cleanup_old_records")
    logger.info(f"[scheduler] started (timezone={tz})")
