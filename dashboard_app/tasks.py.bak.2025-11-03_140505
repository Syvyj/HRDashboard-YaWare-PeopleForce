from __future__ import annotations

import os
import logging
from datetime import date, timedelta
from calendar import monthrange

from .models import AttendanceRecord, db

# імпортуємо РЕАЛЬНУ функцію синку
try:
    from tasks.update_attendance import update_for_date as ua_update_for_date
except Exception as e:
    ua_update_for_date = None
    _ua_import_err = e
else:
    _ua_import_err = None

logger = logging.getLogger("ctrlbot.scheduler")
if not logger.handlers:
    logger.setLevel(logging.INFO)
    _h = logging.StreamHandler()
    _h.setFormatter(logging.Formatter("%(message)s"))
    logger.addHandler(_h)
    logger.propagate = False

def _sync_for_date(d: date):
    """Виклик конкретної реалізації: update_for_date(target_date, include_absent)."""
    if ua_update_for_date is None:
        raise RuntimeError(f"Cannot import tasks.update_attendance.update_for_date: {_ua_import_err}")
    # ВАЖЛИВО: викликаємо позиційно, без kwargs
    return ua_update_for_date(d, True)

# === JOB-и ===
def sync_yesterday():
    target = date.today() - timedelta(days=1)
    logger.info(f"[sync_yesterday] run for {target}")
    _sync_for_date(target)

def sync_prev_month():
    today = date.today()
    prev_month_last_day = today.replace(day=1) - timedelta(days=1)
    year, month = prev_month_last_day.year, prev_month_last_day.month
    start_day = date(year, month, 1)
    days = monthrange(year, month)[1]
    logger.info(f"[sync_prev_month] run for {year}-{month:02d}")
    for i in range(days):
        _sync_for_date(start_day + timedelta(days=i))

def cleanup_old_records():
    """Залишаємо лише «поточний + минулий» місяці (без manual_* правок)."""
    cutoff = date.today().replace(day=1)
    prev_month_cutoff = (cutoff - timedelta(days=1)).replace(day=1)
    deleted = (
        AttendanceRecord.query.filter(
            AttendanceRecord.record_date < prev_month_cutoff,
            AttendanceRecord.manual_notes.is_(False),
            AttendanceRecord.manual_hours.is_(False),
            AttendanceRecord.manual_status.is_(False),
        ).delete(synchronize_session=False)
    )
    db.session.commit()
    logger.info(f"[cleanup_old_records] deleted={deleted}")

# === APScheduler ===
def register_tasks(app):
    # один раз на процес
    if app.config.get("_APS_INIT_DONE"):
        return
    app.config["_APS_INIT_DONE"] = True

    if not app.config.get("ENABLE_SCHEDULER", False):
        logger.info("[scheduler] disabled (ENABLE_SCHEDULER!=1)")
        return

    from apscheduler.schedulers.background import BackgroundScheduler
    tz = os.getenv("TZ", "Europe/Warsaw")

    scheduler = BackgroundScheduler(timezone=tz)
    scheduler.add_job(sync_yesterday,      'cron', hour=2,    minute=0)
    scheduler.add_job(sync_prev_month,     'cron', day=1,     hour=2, minute=30)
    scheduler.add_job(cleanup_old_records, 'cron', day='*/3', hour=3, minute=0)
    scheduler.start()

    logger.info("[scheduler] jobs registered: sync_yesterday, sync_prev_month, cleanup_old_records")
    logger.info(f"[scheduler] started (timezone={tz})")
